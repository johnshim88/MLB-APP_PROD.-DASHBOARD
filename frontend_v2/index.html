<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>26SS 생산 스케줄 대시보드 V2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:," />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.6"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
    <script>
      // API 설정
      // 로컬 개발: http://localhost:8000
      // 배포 시: https://mlb-app-prod-dashboard.onrender.com
      window.API_URL = window.API_URL || "https://mlb-app-prod-dashboard.onrender.com";
    </script>
    <style>
      :root {
        color-scheme: light;
        --bg: #f5f7fb;
        --card: #ffffff;
        --text: #1f2933;
        --muted: #5f6b7c;
        /* 파스텔톤 컬러 팔레트 */
        --target-color: #a5d8ff;
        --actual-color: #d0e7ff;
        --success-color: #86efac;
        --warning-color: #fca5a5;
        --tab-active: #7dd3fc;
        --tab-inactive: #cbd5e1;
        font-family: "Pretendard", "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 20px;
        background: var(--bg);
        color: var(--text);
        overflow-x: hidden;
      }
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }
      header h1 {
        margin: 0;
        font-weight: 700;
        font-size: 1.5rem;
      }
      .export-button {
        padding: 10px 20px;
        background: var(--tab-active);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 0.95rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }
      .export-button:hover {
        background: #60c5f8;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .tab-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 10px;
        margin-bottom: 20px;
        padding: 10px;
      }
      .tab-button {
        padding: 12px 24px;
        border: 2px solid var(--tab-inactive);
        border-radius: 8px;
        background: var(--card);
        color: var(--tab-inactive);
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      .tab-button:hover {
        border-color: var(--tab-active);
        color: var(--tab-active);
      }
      .tab-button.active {
        border-color: var(--tab-active);
        background: var(--tab-active);
        color: white;
      }
      /* 상단 레이아웃: 좌측 원그래프, 우측 KPI 카드 (50:50) */
      .top-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }
      .card {
        background: var(--card);
        padding: 24px;
        border-radius: 14px;
        box-shadow: 0 7px 25px rgba(15, 23, 42, 0.12);
        display: flex;
        flex-direction: column;
      }
      .donut-card {
        min-height: 400px;
      }
      .kpi-column {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .kpi-card {
        background: var(--card);
        border-radius: 14px;
        padding: 20px;
        box-shadow: 0 4px 12px rgba(15, 23, 42, 0.1);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .kpi-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(15, 23, 42, 0.15);
      }
      .kpi-card.highlight {
        background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
        border: 2px solid var(--tab-active);
      }
      .kpi-label {
        color: var(--muted);
        font-size: 0.85rem;
        margin-bottom: 8px;
        font-weight: 500;
      }
      .kpi-value {
        font-size: 1.8rem;
        font-weight: 700;
        color: var(--text);
        margin-bottom: 4px;
      }
      .kpi-sub-value {
        font-size: 1rem;
        font-weight: 600;
        color: var(--tab-active);
        margin-top: 4px;
      }
      h2 {
        font-size: 1.1rem;
        margin: 0 0 15px;
        font-weight: 600;
      }
      .chart-container {
        position: relative;
        width: 100%;
        height: 400px;
        min-height: 400px;
        flex: 1;
      }
      .chart-container-scrollable {
        position: relative;
        width: 100%;
        height: 400px;
        min-height: 400px;
        overflow-y: auto;
        overflow-x: hidden;
      }
      /* 하단 레이아웃: 상단 2개, 하단 2개 */
      .bottom-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }
      .bottom-top {
        grid-column: span 2;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }
      .bottom-bottom {
        grid-column: span 2;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }
      canvas {
        width: 100% !important;
        display: block;
        max-width: 100%;
      }
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(245, 247, 251, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10001;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .loading-overlay.show {
        opacity: 1;
        pointer-events: all;
      }
      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 4px solid var(--card-secondary);
        border-top-color: var(--tab-active);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      .loading-text {
        margin-top: 20px;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text);
      }
      .login-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(245, 247, 251, 0.95);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      }
      .login-form {
        background: var(--card);
        padding: 40px;
        border-radius: 14px;
        box-shadow: 0 7px 25px rgba(15, 23, 42, 0.12);
        min-width: 320px;
      }
      .login-form h2 {
        margin-top: 0;
        margin-bottom: 24px;
        text-align: center;
      }
      .login-form input {
        width: 100%;
        padding: 12px;
        margin-bottom: 16px;
        border: 1px solid rgba(15, 23, 42, 0.15);
        border-radius: 8px;
        font-size: 1rem;
        box-sizing: border-box;
      }
      .login-form button {
        width: 100%;
        padding: 12px;
        background: var(--tab-active);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: opacity 0.3s ease;
      }
      .login-form button:hover {
        opacity: 0.9;
      }
      .login-form .error {
        color: #ef4444;
        font-size: 0.9rem;
        margin-top: -8px;
        margin-bottom: 16px;
        display: none;
      }
      .login-form .error.show {
        display: block;
      }
      .hidden {
        display: none !important;
      }
      .week-select-container {
        text-align: center;
        margin-bottom: 20px;
      }
      .week-select-container label {
        margin-right: 20px;
        cursor: pointer;
      }
      @media (max-width: 1200px) {
        .top-section {
          grid-template-columns: 1fr;
        }
        .bottom-top,
        .bottom-bottom {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <!-- 로그인 폼 -->
    <div id="login-overlay" class="login-overlay">
      <div class="login-form">
        <h2>대시보드 접근</h2>
        <input type="password" id="password-input" placeholder="비밀번호를 입력하세요" />
        <div class="error" id="login-error">비밀번호가 올바르지 않습니다.</div>
        <button id="login-button">로그인</button>
      </div>
    </div>

    <div id="dashboard-content" class="hidden">
      <header>
        <h1>26SS MLB 생산 스케줄 대시보드</h1>
        <div id="data-info" style="font-size: 0.85rem; color: var(--muted);">
          <span id="data-timestamp">데이터 로딩 중...</span>
          <button id="refresh-btn" style="margin-left: 10px; padding: 4px 12px; font-size: 0.8rem; border: 1px solid var(--tab-inactive); border-radius: 4px; background: var(--card); cursor: pointer;">새로고침</button>
        </div>
      </header>

      <!-- 기준 선택 탭 -->
      <div class="tab-container">
        <button class="tab-button active" id="tab-quantity" data-type="quantity">
          수량 기준
        </button>
        <button class="tab-button" id="tab-style-count" data-type="style-count">
          스타일수 기준
        </button>
        <button class="export-button" id="export-button" style="margin-left: auto;">데이터 내보내기</button>
      </div>

      <!-- 주차 선택 -->
      <div id="week-select-container" class="week-select-container">
        <!-- 동적으로 생성됨 -->
      </div>

      <!-- 상단 섹션: 좌측 원그래프, 우측 KPI 카드 -->
      <div class="top-section">
        <!-- 좌측: 원 그래프 -->
        <div class="card donut-card">
          <h2>전체 출고 진행률<span class="week-current"></span></h2>
          <div class="chart-container">
            <canvas id="totalProgress"></canvas>
          </div>
        </div>

        <!-- 우측: KPI 카드 4개 (세로) -->
        <div class="kpi-column">
          <!-- 1행: 26SS 총 오더 스타일 수 -->
          <div class="kpi-card">
            <div class="kpi-label" id="kpi-total-label">26SS 총 오더 스타일 수</div>
            <div class="kpi-value" id="kpi-total">-</div>
          </div>
          <!-- 2행: 출고 목표/완료 수량 (누적) -->
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
            <div class="kpi-card">
              <div class="kpi-label" id="kpi-label-target-cumulative">금주 출고 목표 수량 (누적)</div>
              <div class="kpi-value" id="kpi-target-cumulative">-</div>
              <div class="kpi-sub-value" id="kpi-target-cumulative-pct">-</div>
            </div>
            <div class="kpi-card highlight">
              <div class="kpi-label" id="kpi-label-actual-cumulative">금주 출고 완료 수량 (누적)</div>
              <div class="kpi-value" id="kpi-actual-cumulative">-</div>
              <div class="kpi-sub-value" id="kpi-actual-cumulative-pct">-</div>
            </div>
          </div>
          <!-- 3행: 출고 목표/완료 수량 -->
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
            <div class="kpi-card">
              <div class="kpi-label" id="kpi-label-target">금주 출고 목표 수량</div>
              <div class="kpi-value" id="kpi-target">-</div>
            </div>
            <div class="kpi-card highlight">
              <div class="kpi-label" id="kpi-label-actual">금주 출고 완료 수량</div>
              <div class="kpi-value" id="kpi-actual">-</div>
            </div>
          </div>
        </div>
      </div>

      <!-- 하단 섹션: 막대 그래프 -->
      <div class="bottom-section">
        <!-- 상단 2개 -->
        <div class="bottom-top">
          <div class="card">
            <h2>국가별 현황<span class="week-current"></span></h2>
            <div class="chart-container">
              <canvas id="chart-nations"></canvas>
            </div>
          </div>
          <div class="card">
            <h2>아이템별 현황<span class="week-current"></span></h2>
            <div class="chart-container">
              <canvas id="chart-items"></canvas>
            </div>
          </div>
        </div>

        <!-- 하단 2개 -->
        <div class="bottom-bottom">
          <div class="card">
            <h2>세부 복종별 현황<span class="week-current"></span></h2>
            <div class="chart-container-scrollable">
              <canvas id="chart-subcategories"></canvas>
            </div>
          </div>
          <div class="card">
            <h2>협력사별 현황<span class="week-current"></span></h2>
            <div class="chart-container-scrollable">
              <canvas id="chart-suppliers"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 로딩 오버레이 -->
    <div id="loading-overlay" class="loading-overlay">
      <div class="loading-spinner"></div>
      <div class="loading-text">데이터를 불러오는 중...</div>
    </div>

    <script>
      Chart.register(ChartDataLabels);

      const API_BASE_URL = window.API_URL || "http://localhost:8000";
      let CURRENT_WEEK = null;
      let NEXT_WEEK = null;
      let WEEK_INFO = null;
      let CURRENT_TYPE = "quantity";
      let DATA_URL = `${API_BASE_URL}/api/v2/quantity`;
      let AUTH_HEADERS = {};

      const palette = {
        target: "#a5d8ff",
        actual: "#d0e7ff",
        success: "#86efac",
        warning: "#fca5a5",
      };

      const fmt = new Intl.NumberFormat("ko-KR", {
        maximumFractionDigits: 0,  // 소수점 없이 정수로만 표시
      });
      const pct = new Intl.NumberFormat("ko-KR", {
        style: "percent",
        minimumFractionDigits: 0,  // 퍼센트도 정수로 표시
        maximumFractionDigits: 0,
      });

      const charts = {};
      let cachedData = null;

      // 데이터 내보내기
      async function exportExcel() {
        try {
          showLoading("엑셀 파일 다운로드 중...");
          const response = await fetch(`${API_BASE_URL}/api/v2/export/excel`, {
            headers: AUTH_HEADERS,
            cache: 'no-cache',
          });
          
          if (!response.ok) {
            if (response.status === 401) {
              alert("인증이 만료되었습니다. 다시 로그인해주세요.");
              document.getElementById("login-overlay").classList.remove("hidden");
              document.getElementById("dashboard-content").classList.add("hidden");
              return;
            }
            throw new Error(`다운로드 실패: ${response.status}`);
          }
          
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "26SS_MLB_생산스케쥴_DASHBOARD.xlsx";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
          hideLoading();
        } catch (error) {
          console.error("Export error:", error);
          hideLoading();
          alert("엑셀 파일 다운로드에 실패했습니다.");
        }
      }

      // 로그인 처리
      function handleLogin() {
        console.log("로그인 버튼 클릭됨");
        const passwordInput = document.getElementById("password-input");
        const errorDiv = document.getElementById("login-error");
        const password = passwordInput.value;

        if (!password) {
          console.log("비밀번호가 입력되지 않음");
          errorDiv.classList.add("show");
          return;
        }

        console.log("로그인 시도:", API_BASE_URL);
        errorDiv.classList.remove("show");
        showLoading("인증 중...");

        const encodedPassword = btoa(`user:${password}`);
        AUTH_HEADERS = {
          "Authorization": `Basic ${encodedPassword}`
        };

        // 로그인 검증을 위해 /api/v2/auth/verify 엔드포인트 사용 (파일 로드 없이 인증만 확인)
        console.log("로그인 인증 시도:", `${API_BASE_URL}/api/v2/auth/verify`);
        fetch(`${API_BASE_URL}/api/v2/auth/verify`, {
          headers: AUTH_HEADERS
        })
          .then(resp => {
            console.log("인증 응답 상태:", resp.status);
            if (resp.ok) {
              console.log("로그인 성공 - 대시보드 초기화 중...");
              showLoading("정보 접근 중...");
              document.getElementById("login-overlay").classList.add("hidden");
              document.getElementById("dashboard-content").classList.remove("hidden");
              // 로그인 성공 후 대시보드 초기화
              initDashboard();
            } else if (resp.status === 401) {
              console.log("인증 실패: 잘못된 비밀번호");
              hideLoading();
              errorDiv.classList.add("show");
              passwordInput.value = "";
            } else {
              console.log("인증 오류:", resp.status);
              hideLoading();
              errorDiv.classList.add("show");
              passwordInput.value = "";
              resp.text().then(text => {
                console.error("오류 상세:", text);
              });
            }
          })
          .catch(err => {
            console.error("인증 요청 오류:", err);
            hideLoading();
            errorDiv.classList.add("show");
            passwordInput.value = "";
            alert(`로그인 오류: ${err.message}\n\n서버가 실행 중인지 확인하세요.\nAPI URL: ${API_BASE_URL}`);
          });
      }

      // DOM 로드 후 이벤트 리스너 등록
      document.addEventListener("DOMContentLoaded", () => {
        // 로그인 버튼 이벤트
        const loginButton = document.getElementById("login-button");
        if (loginButton) {
          loginButton.addEventListener("click", handleLogin);
        }
        
        // 비밀번호 입력 필드 엔터 키 이벤트
        const passwordInput = document.getElementById("password-input");
        if (passwordInput) {
          passwordInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") handleLogin();
          });
        }
        
        // 내보내기 버튼 이벤트
        const exportButton = document.getElementById("export-button");
        if (exportButton) {
          exportButton.addEventListener("click", exportExcel);
        }
        
        // 새로고침 버튼 이벤트
        const refreshBtn = document.getElementById("refresh-btn");
        if (refreshBtn) {
          refreshBtn.addEventListener("click", async () => {
            try {
              showLoading("데이터 새로고침 중...");
              const resp = await fetch(`${API_BASE_URL}/api/v2/refresh`, {
                method: "POST",
                headers: AUTH_HEADERS
              });
              if (resp.ok) {
                const result = await resp.json();
                alert(result.message || "데이터가 새로고침되었습니다.");
                // 대시보드 다시 로드
                cachedData = null;
                await initDashboard();
              } else {
                throw new Error("새로고침 실패");
              }
            } catch (error) {
              console.error("새로고침 오류:", error);
              alert("데이터 새로고침에 실패했습니다.");
              hideLoading();
            }
          });
        }
      });

      // 데이터 타임스탬프 업데이트 함수
      function updateDataTimestamp(data) {
        const timestampEl = document.getElementById("data-timestamp");
        if (timestampEl) {
          const now = new Date();
          const timeStr = now.toLocaleString("ko-KR", {
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          });
          timestampEl.textContent = `마지막 업데이트: ${timeStr}`;
        }
      }

      function showLoading(message = "데이터를 불러오는 중...") {
        const overlay = document.getElementById("loading-overlay");
        const loadingText = overlay?.querySelector(".loading-text");
        if (overlay) {
          if (loadingText) loadingText.textContent = message;
          overlay.style.zIndex = "10001";
          overlay.style.display = "flex";
          overlay.classList.add("show");
        }
      }

      function hideLoading() {
        const overlay = document.getElementById("loading-overlay");
        if (overlay) {
          overlay.classList.remove("show");
          setTimeout(() => {
            if (!overlay.classList.contains("show")) {
              overlay.style.display = "";
            }
          }, 300);
        }
      }

      function updateDataType(type) {
        CURRENT_TYPE = type;
        const apiPath = type === "quantity" ? "quantity" : "style-count";
        DATA_URL = `${API_BASE_URL}/api/v2/${apiPath}`;
        
        document.querySelectorAll(".tab-button").forEach((btn) => {
          btn.classList.remove("active");
        });
        document.getElementById(`tab-${type === "quantity" ? "quantity" : "style-count"}`).classList.add("active");
        
        const unitLabel = type === "quantity" ? "수량" : "스타일 수";
        document.getElementById("kpi-total-label").textContent = `26SS 총 오더 ${unitLabel}`;
        
        // KPI 카드 라벨도 업데이트
        updateWeekLabels();
        
        cachedData = null;
        initDashboard();
      }

      document.querySelectorAll(".tab-button").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const type = e.target.dataset.type;
          if (type !== CURRENT_TYPE) {
            updateDataType(type);
          }
        });
      });

      function createWeekSelector(week1, week2) {
        const container = document.getElementById("week-select-container");
        container.innerHTML = `
          <label style="margin-right: 20px; cursor: pointer;">
            <input type="radio" name="week-select" value="${week1}" checked style="margin-right: 6px;" />
            금주 (${week1}주차)
          </label>
          <label style="cursor: pointer;">
            <input type="radio" name="week-select" value="${week2}" style="margin-right: 6px;" />
            차주 (${week2}주차)
          </label>
        `;

        document.querySelectorAll('input[name="week-select"]').forEach((radio) => {
          radio.addEventListener('change', (e) => {
            CURRENT_WEEK = parseInt(e.target.value);
            if (cachedData) {
              refreshDashboardWithCurrentData(cachedData);
            } else {
              initDashboard();
            }
          });
        });
      }

      function updateWeekLabels() {
        // 차주 선택 여부 확인
        const isNextWeek = CURRENT_WEEK === NEXT_WEEK;
        const weekLabel = isNextWeek ? "차주" : "금주";
        
        // 수량/스타일수 기준 확인
        const unitLabel = CURRENT_TYPE === "quantity" ? "수량" : "스타일수";
        
        document.querySelectorAll(".week-current").forEach((el) => {
          el.textContent = ` (${CURRENT_WEEK}주차)`;
        });
        
        // KPI 카드 라벨 업데이트
        if (isNextWeek) {
          document.getElementById("kpi-label-target-cumulative").textContent = `차주 출고 목표 ${unitLabel} (누적)`;
          document.getElementById("kpi-label-actual-cumulative").textContent = `차주 출고 예상 ${unitLabel} (누적)`;
          document.getElementById("kpi-label-target").textContent = `차주 출고 목표 ${unitLabel}`;
          document.getElementById("kpi-label-actual").textContent = `차주 출고 예상 ${unitLabel}`;
        } else {
          document.getElementById("kpi-label-target-cumulative").textContent = `금주 출고 목표 ${unitLabel} (누적)`;
          document.getElementById("kpi-label-actual-cumulative").textContent = `금주 출고 완료 ${unitLabel} (누적)`;
          document.getElementById("kpi-label-target").textContent = `금주 출고 목표 ${unitLabel}`;
          document.getElementById("kpi-label-actual").textContent = `금주 출고 완료 ${unitLabel}`;
        }
      }

      const datasetLabelFormatter = (value, context) => {
        const qty = fmt.format(value ?? 0);
        const datasetIndex = context.datasetIndex;
        const dataIndex = context.dataIndex;
        const chart = context.chart;
        
        // 실적 데이터셋(두 번째, 인덱스 1)인 경우 목표 진행률 계산
        if (datasetIndex === 1 && chart.data.datasets[0]) {
          const targetValue = chart.data.datasets[0].data[dataIndex] ?? 0;
          if (targetValue > 0) {
            const progressPct = Math.round((value / targetValue) * 100);  // 정수로 반올림
            return `${qty} (${progressPct}%)`;
          }
        }
        
        return qty;
      };

      const buildDataset = (rows, { key, pctKey, label, color, isActual = false, targetKey = null }) => {
        const data = rows.map((r) => r[key] ?? 0);
        
        // 실적 데이터셋이고 목표 키가 있으면 진행률에 따라 색상 설정
        let backgroundColor = color;
        if (isActual && targetKey) {
          backgroundColor = data.map((actualValue, index) => {
            const targetValue = rows[index]?.[targetKey] ?? 0;
            if (targetValue > 0) {
              const progressPct = (actualValue / targetValue) * 100;
              if (progressPct <= 90) return '#FF6B6B';  // 90% 이하: 빨간색
              if (progressPct >= 97) return '#00C49F';  // 97% 이상: 초록색
              return '#3A86FF';  // 90% 초과 ~ 97% 미만: 파란색
            }
            return '#3A86FF';
          });
        }
        
        const dataset = {
          label,
          data: data,
          pctData: pctKey ? rows.map((r) => r[pctKey] ?? null) : null,
          backgroundColor: backgroundColor,
          borderRadius: 10,
          barThickness: 18,
          maxBarThickness: 28,
          categoryPercentage: 0.9,
          barPercentage: 0.9,
        };
        console.log(`buildDataset - ${label} (key: ${key}):`, {
          sampleData: rows.slice(0, 2).map(r => ({ row: r, value: r[key] })),
          dataValues: dataset.data.slice(0, 5)
        });
        return dataset;
      };

      const destroyChart = (name) => {
        if (charts[name]) {
          charts[name].destroy();
          delete charts[name];
        }
      };

      async function loadData() {
        try {
          const headers = {...AUTH_HEADERS};
          // ETag 기반 조건부 요청 (속도 최적화)
          // 브라우저 HTTP 캐시는 사용하지 않지만, ETag로 304 응답 받으면 메모리 캐시 사용
          if (cachedData && cachedData._etag) {
            headers['If-None-Match'] = cachedData._etag;
          }
          
          // 타임아웃 설정 (30초)
          const timeoutMs = 30000;
          const controller = new AbortController();
          const timeoutId = setTimeout(() => {
            controller.abort();
          }, timeoutMs);
          
          // 성능 측정 시작
          const loadStartTime = performance.now();
          let resp;
          try {
            resp = await fetch(DATA_URL, {
              headers: headers,
              cache: 'no-cache',  // 브라우저 HTTP 캐시는 저장하지 않지만, 조건부 요청은 가능
              method: 'GET',
              signal: controller.signal
            });
          } catch (fetchError) {
            clearTimeout(timeoutId);
            if (fetchError.name === 'AbortError') {
              throw new Error(`요청 시간이 초과되었습니다 (${timeoutMs/1000}초). 서버가 응답하지 않거나 네트워크가 느립니다.`);
            }
            throw new Error(`네트워크 오류: ${fetchError.message}`);
          }
          clearTimeout(timeoutId);
          
          if (!resp.ok) {
            const errorText = await resp.text();
            console.error("API 응답 오류:", resp.status, errorText);
            if (resp.status === 401) {
              document.getElementById("login-overlay").classList.remove("hidden");
              document.getElementById("dashboard-content").classList.add("hidden");
              throw new Error("인증이 만료되었습니다. 다시 로그인해주세요.");
            } else if (resp.status === 404) {
              // V2 파일이 없는 경우
              throw new Error("V2 파일을 찾을 수 없습니다. 서버 관리자에게 문의하세요. (404)");
            } else if (resp.status === 500) {
              // 서버 에러 - 더 자세한 정보 표시
              console.error("서버 에러 상세:", errorText);
              throw new Error(`서버 오류가 발생했습니다. (500)\n\n에러 상세: ${errorText.substring(0, 200)}\n\n서버 로그를 확인하세요.`);
            }
            throw new Error(`데이터를 불러올 수 없습니다. (${resp.status}: ${errorText.substring(0, 100)})`);
          }
          
          // 304 Not Modified: 데이터가 변경되지 않았으면 메모리 캐시 사용 (매우 빠름)
          if (resp.status === 304) {
            const loadTime = (performance.now() - loadStartTime).toFixed(0);
            console.log(`데이터 변경 없음 (304), 메모리 캐시 사용 (${loadTime}ms)`);
            return cachedData;
          }
          
          // 200 OK: 새로운 데이터 받기
          const parseStartTime = performance.now();
          const data = await resp.json();
          const parseTime = (performance.now() - parseStartTime).toFixed(0);
          const loadTime = (performance.now() - loadStartTime).toFixed(0);
          console.log(`데이터 로드 성공 (${loadTime}ms, 파싱: ${parseTime}ms)`);
          
          // ETag 저장 (다음 요청에서 조건부 요청에 사용)
          const etag = resp.headers.get('ETag');
          if (etag && data) {
            data._etag = etag;
          }
          
          return data;
        } catch (error) {
          console.error("데이터 로드 오류:", error);
          console.error("API URL:", DATA_URL);
          console.error("에러 상세:", error.message, error.stack);
          throw error;
        }
      }

      // KPI 업데이트
      function updateKpis(totalRow, summaryCells) {
        // 기본값 설정
        const kpiIds = [
          "kpi-total", "kpi-target", "kpi-actual",
          "kpi-target-cumulative", "kpi-actual-cumulative",
          "kpi-target-cumulative-pct", "kpi-actual-cumulative-pct"
        ];
        
        if (!totalRow) {
          kpiIds.forEach((id) => {
            const el = document.getElementById(id);
            if (el) el.textContent = "-";
          });
          return;
        }
        
        // 차주 선택 여부 확인
        const isNextWeek = CURRENT_WEEK === NEXT_WEEK;
        
        // 1행: 26SS 총 오더 스타일 수 (기존 데이터 그대로)
        const totalQty = totalRow.total_qty ?? 0;
        document.getElementById("kpi-total").textContent = fmt.format(totalQty);
        
        let targetCumulative, actualCumulative, target, actual;
        
        if (isNextWeek) {
          // 차주 데이터 사용
          // M18, O18: 차주 출고 목표 수량 (누적)
          // N18, P18: 차주 출고 완료 수량 (누적)
          targetCumulative = (summaryCells?.M18 ?? 0) || (summaryCells?.O18 ?? 0);
          actualCumulative = (summaryCells?.N18 ?? 0) || (summaryCells?.P18 ?? 0);
          // K18: 차주 출고 목표 수량
          // L18: 차주 출고 완료 수량
          target = summaryCells?.K18 ?? 0;
          actual = summaryCells?.L18 ?? 0;
        } else {
          // 금주 데이터 사용
          targetCumulative = summaryCells?.F18 ?? 0;
          actualCumulative = summaryCells?.G18 ?? 0;
          target = summaryCells?.D18 ?? 0;
          actual = summaryCells?.E18 ?? 0;
        }
        
        // 2행: 출고 목표 수량 (누적), 출고 완료 수량 (누적)
        document.getElementById("kpi-target-cumulative").textContent = fmt.format(targetCumulative);
        document.getElementById("kpi-actual-cumulative").textContent = fmt.format(actualCumulative);
        
        // 퍼센트 계산 (총 수량 기준)
        const targetCumulativePct = totalQty && totalQty > 0 ? targetCumulative / totalQty : 0;
        const actualCumulativePct = totalQty && totalQty > 0 ? actualCumulative / totalQty : 0;
        document.getElementById("kpi-target-cumulative-pct").textContent = pct.format(targetCumulativePct);
        document.getElementById("kpi-actual-cumulative-pct").textContent = pct.format(actualCumulativePct);
        
        // 3행: 출고 목표 수량, 출고 완료 수량
        document.getElementById("kpi-target").textContent = fmt.format(target);
        document.getElementById("kpi-actual").textContent = fmt.format(actual);
      }

      // 원 그래프 렌더링 (출고 완료 + 누적 완료 수량 표시)
      function renderDonut(totalRow, summaryCells) {
        const target = totalRow?.total_qty ?? 0;
        
        // 차주 선택 여부 확인
        const isNextWeek = CURRENT_WEEK === NEXT_WEEK;
        
        let actualCurrent, actualCumulative, targetCumulative;
        let currentWeekActualCumulative = 0; // 차주 탭에서 금주 완료 데이터를 표시하기 위해
        let currentWeekTargetCumulative = 0; // 차주 탭에서 금주 목표 데이터 (금주 완료 부분 색상 계산용)
        
        if (isNextWeek) {
          // 차주 데이터 사용
          // L18: 차주 출고 완료 수량 - 찐한 색
          actualCurrent = summaryCells?.L18 ?? 0;
          // N18, P18: 차주 출고 완료 수량 (누적) - 연한 색, 가운데 표시
          actualCumulative = (summaryCells?.N18 ?? 0) || (summaryCells?.P18 ?? 0);
          // M18, O18: 차주 출고 목표 수량 (누적) - 흰색으로 추가 표시
          targetCumulative = (summaryCells?.M18 ?? 0) || (summaryCells?.O18 ?? 0);
          // G18: 금주 출고 완료 수량 (누적) - 차주 탭에서 먼저 표시
          currentWeekActualCumulative = summaryCells?.G18 ?? 0;
          // F18: 금주 출고 목표 수량 (누적) - 금주 완료 부분 색상 계산용
          currentWeekTargetCumulative = summaryCells?.F18 ?? 0;
        } else {
          // 금주 데이터 사용
          // E18: 금주 출고 완료 수량 - 찐한 색
          actualCurrent = summaryCells?.E18 ?? 0;
          // G18: 누적 완료 수량 - 연한 색, 가운데 표시
          actualCumulative = summaryCells?.G18 ?? 0;
          // F18: 금주 출고 목표 수량 (누적) - 흰색으로 추가 표시
          targetCumulative = summaryCells?.F18 ?? 0;
        }
        
        const currentProgressPct = Math.min(target && target > 0 ? actualCurrent / target : 0, 1);
        const cumulativeProgressPct = Math.min(target && target > 0 ? actualCumulative / target : 0, 1);
        const targetCumulativeProgressPct = Math.min(target && target > 0 ? targetCumulative / target : 0, 1);
        const currentWeekActualCumulativePct = Math.min(target && target > 0 ? currentWeekActualCumulative / target : 0, 1);
        
        // 목표 진행률 계산 (실적 / 목표 × 100)
        // 차주 탭: 차주 예상에 대한 목표 진행률 (중앙 표시용)
        // 금주 탭: 금주 완료에 대한 목표 진행률 (중앙 표시 및 색상용)
        const targetProgressPct = targetCumulative > 0 ? (actualCumulative / targetCumulative) * 100 : 0;
        // 차주 탭: 금주 완료에 대한 목표 진행률 (금주 완료 부분 색상용)
        // 금주 탭에서는 사용하지 않음 (targetProgressPct 사용)
        const currentWeekTargetProgressPct = isNextWeek && currentWeekTargetCumulative > 0 
          ? (currentWeekActualCumulative / currentWeekTargetCumulative) * 100 
          : (isNextWeek ? 0 : targetProgressPct);

        destroyChart("totalProgress");
        const canvas = document.getElementById("totalProgress");
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = 400;
        
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const outerRadius = Math.min(canvas.width, canvas.height) * 0.35; // 바깥쪽 반지름 (누적)
        const innerRadius = outerRadius - 25; // 안쪽 반지름 (금주)
        const lineWidth = 20; // 링 두께
        
          // 애니메이션을 위한 진행률
          let currentProgress = 0;
          let cumulativeProgress = 0;
          let targetCumulativeProgress = 0;
          let currentWeekActualCumulativeProgress = 0;
          const animationDuration = 1000;
          const startTime = Date.now();
          
          function animate() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / animationDuration, 1);
            currentProgress = currentProgressPct * progress;
            cumulativeProgress = cumulativeProgressPct * progress;
            targetCumulativeProgress = targetCumulativeProgressPct * progress;
            currentWeekActualCumulativeProgress = currentWeekActualCumulativePct * progress;
            
            // 캔버스 클리어
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 바깥쪽 링: 목표 전체를 회색 배경으로 먼저 그리기
            if (targetCumulativeProgress > 0) {
              ctx.beginPath();
              ctx.arc(centerX, centerY, outerRadius, -Math.PI / 2, -Math.PI / 2 + targetCumulativeProgress * 2 * Math.PI);
              ctx.strokeStyle = '#E9ECEF'; // 회색 배경
              ctx.lineWidth = lineWidth;
              ctx.lineCap = 'round';
              ctx.stroke();
            }
            
            // 바깥쪽 링: 실적을 컬러로 그리기 (목표 위에)
            if (isNextWeek) {
              // 차주 탭: 금주 완료 부분 먼저
              if (currentWeekActualCumulativeProgress > 0) {
                // 목표 진행률에 따라 색상 결정
                let currentWeekColor;
                if (currentWeekTargetProgressPct <= 90) {
                  currentWeekColor = '#FF6B6B'; // 90% 이하: 빨간색
                } else if (currentWeekTargetProgressPct >= 97) {
                  currentWeekColor = '#00C49F'; // 97% 이상: 초록색
                } else {
                  currentWeekColor = '#3A86FF'; // 기본: 파란색
                }
                
                // 실적이 목표를 넘지 않도록 제한
                const actualProgress = Math.min(currentWeekActualCumulativeProgress, targetCumulativeProgress);
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, -Math.PI / 2, -Math.PI / 2 + actualProgress * 2 * Math.PI);
                ctx.strokeStyle = currentWeekColor;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.stroke();
              }
              
              // 차주 탭: 차주 예상 부분
              if (cumulativeProgress > currentWeekActualCumulativeProgress) {
                // 목표 진행률에 따라 색상 결정
                let nextWeekColor;
                if (targetProgressPct <= 90) {
                  nextWeekColor = '#FF6B6B'; // 90% 이하: 빨간색
                } else if (targetProgressPct >= 97) {
                  nextWeekColor = '#00C49F'; // 97% 이상: 초록색
                } else {
                  nextWeekColor = '#3A86FF'; // 기본: 파란색
                }
                
                // 실적이 목표를 넘지 않도록 제한
                const startAngle = -Math.PI / 2 + currentWeekActualCumulativeProgress * 2 * Math.PI;
                const endProgress = Math.min(cumulativeProgress, targetCumulativeProgress);
                const endAngle = -Math.PI / 2 + endProgress * 2 * Math.PI;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle);
                ctx.strokeStyle = nextWeekColor;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.stroke();
              }
            } else {
              // 금주 탭: 누적 완료 수량
              // 목표 진행률에 따라 색상 결정
              let cumulativeColor;
              if (targetProgressPct <= 90) {
                cumulativeColor = '#FF6B6B'; // 90% 이하: 빨간색
              } else if (targetProgressPct >= 97) {
                cumulativeColor = '#00C49F'; // 97% 이상: 초록색
              } else {
                cumulativeColor = '#3A86FF'; // 기본: 파란색
              }
              
              // 실적이 목표를 넘지 않도록 제한
              const actualProgress = Math.min(cumulativeProgress, targetCumulativeProgress);
              ctx.beginPath();
              ctx.arc(centerX, centerY, outerRadius, -Math.PI / 2, -Math.PI / 2 + actualProgress * 2 * Math.PI);
              ctx.strokeStyle = cumulativeColor;
              ctx.lineWidth = lineWidth;
              ctx.lineCap = 'round';
              ctx.stroke();
            }
          
          // 안쪽 링: 금주 출고 완료 수량 (찐한 색)
          const currentGradient = ctx.createLinearGradient(
            centerX - innerRadius, centerY - innerRadius,
            centerX + innerRadius, centerY + innerRadius
          );
          currentGradient.addColorStop(0, '#7dd3fc'); // 찐한 파란색
          currentGradient.addColorStop(0.5, '#60c5f8');
          currentGradient.addColorStop(1, '#3b82f6'); // 더 찐한 파란색
          
          ctx.beginPath();
          ctx.arc(centerX, centerY, innerRadius, -Math.PI / 2, -Math.PI / 2 + currentProgress * 2 * Math.PI);
          ctx.strokeStyle = currentGradient;
          ctx.lineWidth = lineWidth;
          ctx.lineCap = 'round';
          ctx.stroke();
          
          // 시작점 원형 마커 (바깥쪽)
          ctx.beginPath();
          ctx.arc(centerX, centerY - outerRadius, lineWidth / 2, 0, 2 * Math.PI);
          if (isNextWeek && currentWeekActualCumulativeProgress > 0) {
            // 목표 진행률에 따라 색상 결정
            let currentWeekColor;
            if (currentWeekTargetProgressPct <= 90) {
              currentWeekColor = '#FF6B6B';
            } else if (currentWeekTargetProgressPct >= 97) {
              currentWeekColor = '#00C49F';
            } else {
              currentWeekColor = '#3A86FF';
            }
            ctx.fillStyle = currentWeekColor;
          } else {
            // 금주 탭: 목표 진행률에 따라 색상 결정
            let cumulativeColor;
            if (targetProgressPct <= 90) {
              cumulativeColor = '#FF6B6B';
            } else if (targetProgressPct >= 97) {
              cumulativeColor = '#00C49F';
            } else {
              cumulativeColor = '#3A86FF';
            }
            ctx.fillStyle = cumulativeColor;
          }
          ctx.fill();
          
          // 끝점 원형 마커 (금주 완료 - 차주 탭일 경우)
          if (isNextWeek && currentWeekActualCumulativeProgress > 0) {
            const actualProgress = Math.min(currentWeekActualCumulativeProgress, targetCumulativeProgress);
            const endAngle = -Math.PI / 2 + actualProgress * 2 * Math.PI;
            const endX = centerX + outerRadius * Math.cos(endAngle);
            const endY = centerY + outerRadius * Math.sin(endAngle);
            ctx.beginPath();
            ctx.arc(endX, endY, lineWidth / 2, 0, 2 * Math.PI);
            let currentWeekColor;
            if (currentWeekTargetProgressPct <= 90) {
              currentWeekColor = '#FF6B6B';
            } else if (currentWeekTargetProgressPct >= 97) {
              currentWeekColor = '#00C49F';
            } else {
              currentWeekColor = '#3A86FF';
            }
            ctx.fillStyle = currentWeekColor;
            ctx.fill();
          }
          
          // 끝점 원형 마커 (누적 완료 - 차주 탭이면 차주 예상, 금주 탭이면 누적 완료)
          if (cumulativeProgress > 0) {
            const actualProgress = Math.min(cumulativeProgress, targetCumulativeProgress);
            const endAngle = -Math.PI / 2 + actualProgress * 2 * Math.PI;
            const endX = centerX + outerRadius * Math.cos(endAngle);
            const endY = centerY + outerRadius * Math.sin(endAngle);
            ctx.beginPath();
            ctx.arc(endX, endY, lineWidth / 2, 0, 2 * Math.PI);
            if (isNextWeek && cumulativeProgress > currentWeekActualCumulativeProgress) {
              // 차주 탭: 차주 예상 부분 - 목표 진행률에 따라 색상 결정
              let nextWeekColor;
              if (targetProgressPct <= 90) {
                nextWeekColor = '#FF6B6B';
              } else if (targetProgressPct >= 97) {
                nextWeekColor = '#00C49F';
              } else {
                nextWeekColor = '#3A86FF';
              }
              ctx.fillStyle = nextWeekColor;
            } else {
              // 금주 탭: 목표 진행률에 따라 색상 결정
              let cumulativeColor;
              if (targetProgressPct <= 90) {
                cumulativeColor = '#FF6B6B';
              } else if (targetProgressPct >= 97) {
                cumulativeColor = '#00C49F';
              } else {
                cumulativeColor = '#3A86FF';
              }
              ctx.fillStyle = cumulativeColor;
            }
            ctx.fill();
          }
          
          // 끝점 원형 마커 (금주)
          if (currentProgress > 0) {
            const endAngle = -Math.PI / 2 + currentProgress * 2 * Math.PI;
            const endX = centerX + innerRadius * Math.cos(endAngle);
            const endY = centerY + innerRadius * Math.sin(endAngle);
            ctx.beginPath();
            ctx.arc(endX, endY, lineWidth / 2, 0, 2 * Math.PI);
            ctx.fillStyle = currentGradient;
            ctx.fill();
          }
          
          // 중앙 텍스트 (누적수량 표시)
          ctx.save();
          
          // 누적 완료 수량 (큰 숫자, 위쪽)
          ctx.font = 'bold 36px Pretendard';
          ctx.fillStyle = '#1f2933';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(fmt.format(actualCumulative), centerX, centerY - 30);
          
          // 진행률% (그라데이션, 중간)
          ctx.font = 'bold 32px Pretendard';
          const textGradient = ctx.createLinearGradient(centerX - 60, centerY + 5, centerX + 60, centerY + 5);
          textGradient.addColorStop(0, '#3b82f6'); // 파란색
          textGradient.addColorStop(1, '#60c5f8'); // 연한 파란색
          ctx.fillStyle = textGradient;
          ctx.fillText(pct.format(cumulativeProgress), centerX, centerY + 15);
          
          // 목표 진행률 (괄호, 아래쪽)
          ctx.font = '600 24px Pretendard';
          ctx.fillStyle = '#5f6b7c';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const targetProgressText = `(목표 대비 진행률: ${Math.round(targetProgressPct)}%)`;  // 정수로 반올림
          ctx.fillText(targetProgressText, centerX, centerY + 45);
          
          ctx.restore();
          
          // 애니메이션 계속
          if (progress < 1) {
            requestAnimationFrame(animate);
          }
        }
        
        animate();
        
        // Chart.js 객체 대신 간단한 객체로 저장 (차트 관리용)
        charts.totalProgress = {
          destroy: function() {
            // 애니메이션 중지는 자동으로 처리됨
          }
        };
      }

      function renderHorizontalChart(canvasId, labels, datasets) {
        destroyChart(canvasId);
        const canvas = document.getElementById(canvasId);
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = 400;
        
        charts[canvasId] = new Chart(canvas, {
          type: "bar",
          data: { labels, datasets },
          options: {
            indexAxis: "y",
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: { top: 10, bottom: 30, right: 80 } },
            scales: {
              x: {
                beginAtZero: true,
                ticks: { 
                  callback: (value) => fmt.format(value),
                  font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
                },
                grid: { drawBorder: false },
              },
              y: {
                ticks: { 
                  autoSkip: false,
                  font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
                },
                grid: { display: false },
              },
            },
            interaction: { mode: "nearest", intersect: false, axis: "y" },
            plugins: {
              legend: {
                position: "bottom",
                labels: { 
                  usePointStyle: true,
                  font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
                },
              },
              datalabels: {
                anchor: "end",
                align: "end",
                color: "#1f2933",
                clip: false,
                formatter: datasetLabelFormatter,
                font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
              },
            },
          },
        });
      }

      function getWeekKeys(week) {
        return {
          target: `target_${week}`,
          actual: `actual_${week}`,
          targetPct: `target_${week}_pct`,
          actualPct: `actual_${week}_pct`,
        };
      }

      function renderNations(rows) {
        const data = rows.filter(
          (row) => (row.code || row.country || "").toUpperCase() !== "TOTAL"
        );
        
        console.log("renderNations - 원본 데이터:", rows);
        console.log("renderNations - 필터링된 데이터:", data);
        console.log("renderNations - CURRENT_WEEK:", CURRENT_WEEK);
        
        const labels = data.map((row) => row.code || row.country || "-");
        
        // 차주 선택 여부 확인
        const isNextWeek = CURRENT_WEEK === NEXT_WEEK;
        const weekLabel = isNextWeek ? "차주" : "금주";
        
        // 차주이면 target_next, actual_next 사용, 아니면 target_cumulative, actual_cumulative 사용
        const targetKey = isNextWeek ? "target_next" : "target_cumulative";
        const actualKey = isNextWeek ? "actual_next" : "actual_cumulative";
        const datasets = [
          buildDataset(data, {
            key: targetKey,
            pctKey: null,
            label: `${CURRENT_WEEK}주 목표 (누적)`,
            color: "#E9ECEF",
          }),
          buildDataset(data, {
            key: actualKey,
            pctKey: null,
            label: `${CURRENT_WEEK}주 실적 (누적)`,
            color: "#3A86FF",
            isActual: true,
            targetKey: targetKey,
          }),
        ];
        
        console.log("renderNations - 생성된 datasets:", datasets);
        renderHorizontalChart("chart-nations", labels, datasets);
      }

      function renderItems(rows) {
        const labels = rows.map((row) => row.item || "-");
        
        // 차주 선택 여부 확인
        const isNextWeek = CURRENT_WEEK === NEXT_WEEK;
        
        // 차주이면 target_next, actual_next 사용, 아니면 target_cumulative, actual_cumulative 사용
        const targetKey = isNextWeek ? "target_next" : "target_cumulative";
        const actualKey = isNextWeek ? "actual_next" : "actual_cumulative";
        const datasets = [
          buildDataset(rows, {
            key: targetKey,
            pctKey: null,
            label: `${CURRENT_WEEK}주 목표 (누적)`,
            color: "#E9ECEF",
          }),
          buildDataset(rows, {
            key: actualKey,
            pctKey: null,
            label: `${CURRENT_WEEK}주 실적 (누적)`,
            color: "#3A86FF",
            isActual: true,
            targetKey: targetKey,
          }),
        ];
        renderHorizontalChart("chart-items", labels, datasets);
      }

      function renderSubcategoryChart(rows) {
        destroyChart("chart-subcategories");
        const canvas = document.getElementById("chart-subcategories");
        const container = canvas.parentElement;
        // 컨테이너 너비에 맞춰 canvas 너비 설정
        const containerWidth = container.clientWidth || container.offsetWidth || 800;
        canvas.width = containerWidth;
        
        // TOTAL 제거 및 빈 항목 제거
        const filteredRows = rows.filter((row) => {
          // index를 기준으로 필터링 (S열 값)
          const index = String(row.index || "").trim().toUpperCase();
          // subcategory도 체크 (TOTAL 제거)
          const subcat = String(row.subcategory || "").toUpperCase();
          
          // index가 없거나 TOTAL이면 제외
          if (!index || index === "" || index === "TOTAL") {
            return false;
          }
          if (subcat === "TOTAL") {
            return false;
          }
          
          return true;
        });
        
        console.log("세부 복종별 필터링 후 항목 수:", filteredRows.length);
        console.log("세부 복종별 항목 목록:", filteredRows.map(r => r.index));
        
        if (!filteredRows.length) {
          charts["chart-subcategories"] = new Chart(
            canvas,
            { 
              type: "bar", 
              data: { labels: [], datasets: [] },
              options: {
                responsive: true,
                maintainAspectRatio: false,
              }
            }
          );
          return;
        }

        // S열(인덱스)를 라벨로 사용, W열(누적 목표), X열(누적 수량) 사용
        const labels = filteredRows.map((row) => {
          const index = row.index ?? row.subcategory ?? "-";
          return String(index);
        });

        // 전체 항목 높이로 차트를 그리고, 컨테이너는 스크롤로 5개만 보이게
        const itemHeight = 60;  // 각 항목 높이 (간격 확대)
        const totalHeight = Math.max(400, filteredRows.length * itemHeight + 150);  // 전체 항목 높이 (최소 400px)
        
        // 차트 생성 전에 canvas 크기 명시적으로 설정
        canvas.height = totalHeight;
        canvas.style.height = totalHeight + 'px';
        canvas.style.width = '100%';
        canvas.style.display = 'block';  // 인라인 요소로 인한 여백 제거

        // 차주 선택 여부 확인
        const isNextWeek = CURRENT_WEEK === NEXT_WEEK;
        
        const targetData = filteredRows.map((r) => isNextWeek ? (r.target_next ?? 0) : (r.target_cumulative ?? 0));
        const actualData = filteredRows.map((r) => isNextWeek ? (r.actual_next ?? 0) : (r.actual_cumulative ?? 0));
        
        // 진행률에 따라 실적 색상 설정
        const actualColors = actualData.map((actualValue, index) => {
          const targetValue = targetData[index] ?? 0;
          if (targetValue > 0) {
            const progressPct = (actualValue / targetValue) * 100;
            if (progressPct <= 90) return '#FF6B6B';  // 90% 이하: 빨간색
            if (progressPct >= 97) return '#00C49F';  // 97% 이상: 초록색
            return '#3A86FF';  // 90% 초과 ~ 97% 미만: 파란색
          }
          return '#3A86FF';
        });
        
        const datasets = [
          {
            label: `${CURRENT_WEEK}주 목표 (누적)`,
            data: targetData,
            pctData: null,
            backgroundColor: "#E9ECEF",
            borderRadius: 8,
            barThickness: 22,
            maxBarThickness: 25,
          },
          {
            label: `${CURRENT_WEEK}주 실적 (누적)`,
            data: actualData,
            pctData: null,
            backgroundColor: actualColors,
            borderRadius: 8,
            barThickness: 22,
            maxBarThickness: 25,
          },
        ];

        charts["chart-subcategories"] = new Chart(canvas, {
          type: "bar",
          data: { labels, datasets },
          options: {
            indexAxis: "y",
            responsive: false,  // 컨테이너 크기에 맞추지 않고 canvas 크기 그대로 사용
            maintainAspectRatio: false,
            devicePixelRatio: 1,  // 고해상도 디스플레이 대응
            layout: { 
              padding: { 
                top: 10, 
                bottom: 30, 
                right: 100,
                left: 10
              } 
            },
            scales: {
              x: {
                beginAtZero: true,
                ticks: { 
                  callback: (value) => fmt.format(value),
                  font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
                },
                grid: { drawBorder: false },
              },
              y: {
                ticks: { 
                  autoSkip: false,
                  stepSize: 1,  // 모든 항목 표시
                  callback: function(value, index) {
                    // 모든 라벨 표시
                    return labels[index] || '';
                  },
                  font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
                },
                grid: { display: false },
                afterBuildTicks: function(scale) {
                  // 모든 항목에 대한 틱 생성 (강제)
                  const ticks = [];
                  for (let i = 0; i < labels.length; i++) {
                    ticks.push({
                      value: i,
                      label: labels[i] || ''
                    });
                  }
                  scale.ticks = ticks;
                },
                afterSetDimensions: function(scale) {
                  // 차트 높이를 모든 항목이 들어갈 수 있도록 설정
                  const itemHeight = 60;
                  const calculatedHeight = labels.length * itemHeight;
                  scale.height = calculatedHeight;
                  scale.maxHeight = calculatedHeight;
                },
                afterFit: function(scale) {
                  // 차트가 그려진 후에도 높이 유지
                  const itemHeight = 60;
                  const calculatedHeight = labels.length * itemHeight;
                  if (scale.height < calculatedHeight) {
                    scale.height = calculatedHeight;
                  }
                },
                categoryPercentage: 0.7,  // 카테고리 간 간격 (작을수록 간격이 큼)
                barPercentage: 0.8  // 막대 간 간격 (작을수록 간격이 큼)
              },
            },
            interaction: { mode: "nearest", intersect: false, axis: "y" },
            plugins: {
              legend: {
                position: "bottom",
                labels: { 
                  usePointStyle: true,
                  font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
                },
              },
              datalabels: {
                anchor: "end",
                align: "end",
                color: "#1f2933",
                clip: false,
                formatter: datasetLabelFormatter,
                font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
              },
            },
            onResize: function(chart) {
              // 차트 크기 변경 시에도 높이 유지
              const itemHeight = 60;
              const calculatedHeight = labels.length * itemHeight + 150;
              if (chart.canvas.height < calculatedHeight) {
                chart.canvas.height = calculatedHeight;
                chart.canvas.style.height = calculatedHeight + 'px';
                chart.resize();
              }
            }
          },
        });
        
        // 차트 생성 후 강제로 크기 재설정
        setTimeout(() => {
          const finalHeight = Math.max(400, filteredRows.length * 60 + 150);
          if (canvas.height !== finalHeight) {
            canvas.height = finalHeight;
            canvas.style.height = finalHeight + 'px';
            charts["chart-subcategories"].resize();
          }
        }, 100);
      }

      function renderSuppliers(suppliersData) {
        destroyChart("chart-suppliers");
        const canvas = document.getElementById("chart-suppliers");
        const container = canvas.parentElement;
        // 컨테이너 너비에 맞춰 canvas 너비 설정
        const containerWidth = container.clientWidth || container.offsetWidth || 800;
        canvas.width = containerWidth;
        
        // 전체 항목 높이로 차트를 그리고, 컨테이너는 스크롤로 보이게
        const itemHeight = 60;  // 세부 복종별과 동일한 높이
        const totalHeight = suppliersData && suppliersData.length > 0 
          ? suppliersData.length * itemHeight + 150
          : 400;
        canvas.height = totalHeight;
        canvas.style.height = totalHeight + 'px';
        canvas.style.width = '100%';
        canvas.style.display = 'block';
        
        console.log("협력사 데이터:", suppliersData);
        if (!suppliersData || suppliersData.length === 0) {
          charts["chart-suppliers"] = new Chart(canvas, {
            type: "bar",
            data: { 
              labels: [],
              datasets: []
            },
            options: {
              indexAxis: "y",
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: false
                },
                tooltip: {
                  enabled: false
                }
              },
              scales: {
                x: {
                  beginAtZero: true,
                  display: false
                },
                y: {
                  display: false
                }
              }
            },
            plugins: [{
              id: 'noDataText',
              afterDraw: (chart) => {
                const ctx = chart.ctx;
                const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
                const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2;
                
                ctx.save();
                ctx.font = '600 16px Pretendard';
                ctx.fillStyle = '#9ca3af';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('협력사 데이터 준비 중', centerX, centerY);
                ctx.restore();
              }
            }]
          });
          return;
        }
        
        // AK열(인덱스)를 라벨로 사용, AO열(누적 목표), AP열(누적 실제) 사용
        const labels = suppliersData.map((s) => {
          const index = s.index ?? s.name ?? "-";
          return String(index);
        });
        
        // 차주 선택 여부 확인
        const isNextWeek = CURRENT_WEEK === NEXT_WEEK;
        
        const targetData = suppliersData.map((s) => isNextWeek ? (s.target_next ?? 0) : (s.target_cumulative ?? 0));
        const actualData = suppliersData.map((s) => isNextWeek ? (s.actual_next ?? 0) : (s.actual_cumulative ?? 0));
        
        // 진행률에 따라 실적 색상 설정
        const actualColors = actualData.map((actualValue, index) => {
          const targetValue = targetData[index] ?? 0;
          if (targetValue > 0) {
            const progressPct = (actualValue / targetValue) * 100;
            if (progressPct <= 90) return '#FF6B6B';  // 90% 이하: 빨간색
            if (progressPct >= 97) return '#00C49F';  // 97% 이상: 초록색
            return '#3A86FF';  // 90% 초과 ~ 97% 미만: 파란색
          }
          return '#3A86FF';
        });
        
        charts["chart-suppliers"] = new Chart(canvas, {
          type: "bar",
          data: {
            labels: labels,
            datasets: [
              {
                label: `${CURRENT_WEEK}주 목표 (누적)`,
                data: targetData,
                backgroundColor: "#E9ECEF",
                borderRadius: 8,
                barThickness: 22,  // 세부 복종별과 동일한 두께
                maxBarThickness: 25,
              },
              {
                label: `${CURRENT_WEEK}주 실적 (누적)`,
                data: actualData,
                backgroundColor: actualColors,
                borderRadius: 8,
                barThickness: 22,  // 세부 복종별과 동일한 두께
                maxBarThickness: 25,
              }
            ]
          },
          options: {
            indexAxis: "y",
            responsive: false,  // 컨테이너 크기에 맞추지 않고 canvas 크기 그대로 사용
            maintainAspectRatio: false,
            devicePixelRatio: 1,  // 고해상도 디스플레이 대응
            layout: { 
              padding: { 
                top: 15, 
                bottom: 35, 
                right: 80,
                left: 15
              } 
            },
            scales: {
              x: {
                beginAtZero: true,
                ticks: { 
                  callback: (value) => fmt.format(value),
                  font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
                },
                grid: { drawBorder: false },
              },
              y: {
                ticks: { 
                  autoSkip: false,
                  stepSize: 1,
                  font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
                },
                grid: { display: false },
                afterBuildTicks: function(scale) {
                  // 모든 항목에 대한 틱 생성
                  scale.ticks = labels.map((label, index) => ({
                    value: index,
                    label: label
                  }));
                },
                categoryPercentage: 0.7,  // 카테고리 간 간격 (작을수록 간격이 큼)
                barPercentage: 0.8  // 막대 간 간격 (작을수록 간격이 큼)
              },
            },
            interaction: { mode: "nearest", intersect: false, axis: "y" },
            plugins: {
              legend: {
                position: "bottom",
                labels: { 
                  usePointStyle: true,
                  font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
                },
              },
              datalabels: {
                anchor: "end",
                align: "end",
                color: "#1f2933",
                clip: false,
                formatter: datasetLabelFormatter,
                font: { family: 'Pretendard, "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif' }
              },
            },
          },
        });
        
        // 차트 생성 후 강제로 크기 재설정
        setTimeout(() => {
          const finalHeight = suppliersData.length * 60 + 150;
          if (canvas.height !== finalHeight) {
            canvas.height = finalHeight;
            canvas.style.height = finalHeight + 'px';
            charts["chart-suppliers"].resize();
          }
        }, 100);
      }

      function refreshDashboardWithCurrentData(data) {
        const nations = data.nations || [];
        const items = data.items || [];
        const subcategories = data.sub_categories || data.subCategories || [];

        const totalRow = CURRENT_TYPE === "style-count"
          ? items.find((row) => (row.item || "").toUpperCase() === "TOTAL")
          : nations.find((row) => (row.code || "").toUpperCase() === "TOTAL");

        const summaryCells = data.summary_cells || {};
        const suppliers = data.suppliers || [];
        
        updateWeekLabels();
        updateKpis(totalRow, summaryCells);
        renderDonut(totalRow, summaryCells);
        renderNations(nations);
        renderItems(items);
        renderSubcategoryChart(subcategories);
        renderSuppliers(suppliers);
      }

      async function initDashboard() {
        try {
          showLoading();
          const data = await loadData();
          
          cachedData = data;
          
          WEEK_INFO = data.week_info || { current_week: 48, next_week: 49 };
          const defaultCurrentWeek = WEEK_INFO.current_week;
          NEXT_WEEK = WEEK_INFO.next_week;

          if (!document.querySelector('input[name="week-select"]')) {
            createWeekSelector(defaultCurrentWeek, NEXT_WEEK);
            CURRENT_WEEK = defaultCurrentWeek;
          } else {
            const selectedRadio = document.querySelector('input[name="week-select"]:checked');
            if (selectedRadio) {
              CURRENT_WEEK = parseInt(selectedRadio.value);
            } else {
              CURRENT_WEEK = defaultCurrentWeek;
            }
          }
          
          const renderStartTime = performance.now();
          const nations = data.nations || [];
          const items = data.items || [];
          const subcategories = data.sub_categories || data.subCategories || [];

          const totalRow = CURRENT_TYPE === "style-count"
            ? items.find((row) => (row.item || "").toUpperCase() === "TOTAL")
            : nations.find((row) => (row.code || "").toUpperCase() === "TOTAL");

          const summaryCells = data.summary_cells || {};
          const suppliers = data.suppliers || [];
          
          // 차트 렌더링 최적화: 즉시 보이는 차트부터 렌더링
          updateWeekLabels();
          updateKpis(totalRow, summaryCells);
          
          // 가장 중요한 차트는 즉시 렌더링 (사용자가 먼저 보게)
          renderDonut(totalRow, summaryCells);
          
          // 나머지 차트는 requestIdleCallback으로 병렬 렌더링 (브라우저가 유휴 시간에 처리)
          if ('requestIdleCallback' in window) {
            // 국가별, 아이템별 차트는 우선순위 높게 (화면 상단에 보임)
            requestIdleCallback(() => {
              renderNations(nations);
              renderItems(items);
            }, { timeout: 100 });
            
            // 세부 복종별, 협력사별 차트는 낮은 우선순위 (스크롤해야 보임)
            requestIdleCallback(() => {
              renderSubcategoryChart(subcategories);
              renderSuppliers(suppliers);
            }, { timeout: 2000 });
          } else {
            // requestIdleCallback 미지원 브라우저는 기존 방식 사용
            requestAnimationFrame(() => {
              renderNations(nations);
              renderItems(items);
              requestAnimationFrame(() => {
                renderSubcategoryChart(subcategories);
                renderSuppliers(suppliers);
              });
            });
          }
          
          const renderTime = (performance.now() - renderStartTime).toFixed(0);
          console.log(`대시보드 렌더링 완료 (${renderTime}ms)`);
          
          // 데이터 타임스탬프 표시
          updateDataTimestamp(data);
          
          hideLoading();
        } catch (error) {
          console.error("Dashboard initialization error:", error);
          hideLoading();
          const errorMsg = error.message || "알 수 없는 오류가 발생했습니다.";
          alert(`대시보드 데이터를 불러오지 못했습니다.\n\n오류: ${errorMsg}\n\n서버 상태 및 API URL을 확인하세요.\nAPI URL: ${DATA_URL}`);
        }
      }
    </script>
  </body>
</html>
